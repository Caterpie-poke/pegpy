/**
 * Konoha6 (Chibi Konoha) Grammar
 *
 * Authors:
 *   Kimio Kuramitsu (https://github.com/kkuramitsu/)
 */

/* Starting Point */

File = __  { (Statement __)* #Block } EOF

EOF          = !.
NL           = '\n' / EOF
S            = [ \t\rã€€]

_            = ( S / BLOCKCOMMENT / LINECOMMENT )*
__           = ( S / '\n' / BLOCKCOMMENT / LINECOMMENT )*
SPC          = ( S / BLOCKCOMMENT / LINECOMMENT )+

BLOCKCOMMENT = '/*' ( !'*/' . )* '*/'
             / '(*' ( !'*)' . )* '*)'
LINECOMMENT  = '//' ( !NL . )*

EOL          = _ NL (_ NL)*
INDENT       = '\n' S*

/* Token */

"{" = '{' __
"}" = __ '}' _
"[" = '[' __
"]" = __ ']' _
"(" = '(' __
")" = __ ')' _
"<" = '<' _
">" = '>' _
"=" = '=' !'=' _
"," = ',' __
";" = (';' _)+
":" = ':' __

/* Identifier */

Identifier = { NAME [']* #NameExpr } _
           / '(' { OPNAME #NameExpr } ')' _
NAME       = [a-zA-Z_\x80-\xF7] W*
W          = [a-zA-Z0-9\x80-\xF7]

OPNAME =
	/ '++'  / '+'
	/ '-->' / '->' / '--' / '-'
	/ '**'  / '*'
	/ '^^'  / '^'
	/ '/'
	/ '%'
	/ '&&&' / '&&' / '&'
	/ '|||' / '||' / '|'
	/ '===' / '==>' / '==' / '=>'
	/ '!='  / '!'
	/ '>='  / '>>' / '>'
	/ '<='  / '<<' / '<'
	/ '::'
	/ '~'

example Identifier abc
example Identifier (+)

/* Type */

example Type String
example Type ()
example Type Dict[Int]
example Type () -> int
example Type int -> int -> int
example Type (int, int)
example Type {name, age}

Type =
	PrimaryType (
	    base:^ { "[" params: Types "]" #ParamType }
	    / base:^ { '->' _ type: Type #FuncType }
	)*

PrimaryType =
	{ 'typeof' "(" expr: Expression ")" #ExprType }
	/ TupleType
	/ DataType
	/ BaseType

BaseType = !TKEYWORD TypeName

TKEYWORD
	= 'public' !W
	/ 'let' !W

TypeName = {
	[A-Za-z$\x80-\xF7]	[A-Za-z0-9/.\x80-\xF7]* [']*
	#BaseType
} _

TupleType = {
	"(" ( Type ("," Type)* )? ")"
	#TupleType
}

Types = {
	( Type ("," Type)* )?
}

DataType =  {
    "{"
	(Identifier ("," Identifier)*)?
	"}"
	#DataType
}

/* Statement */

Statement =
    / Decorator
	/ LetDecl
	/ AssumeDecl
	/ CodeDecl
	/ FuncDecl
	/ AssignStmt
	/ Expression

/* Decorator */

example Decorator, Statement '''
@contract(MyCoin)
f(x) = x + 1
'''

Decorator = {
    '@' name: Identifier
    ("(" params: Params ")")? __
    body: Statement
    #Decorator
}

/* AssumeDecl */

example AssumeDecl, Statement '''
assume x,y,z : Float
'''

AssumeDecl = {
  'assume' !W _
  names: Names
  ":"
  type: Type
  #AssumeDecl
}

Names = {
  Identifier ("," Identifier)*
}

CodeDecl = {
  'codemap' !W __
  (CodeMap __)*
  #CodeDecl
}

example CodeDecl, Statement '''
codemap
    +@2: Int->Int = +${1}
    -@2: Int->Int = -${1}
'''

/* LetDecl */

LetDecl = {
	'let' SPC
	name: Identifier
	(":" type: Type)?
	"="
	expr: Expression
	#LetDecl
}

AssignStmt = {
	left: LeftHand
    "="
    right: Expression
	#Assign
}

/* FuncDecl */

example FuncDecl, Statement '''
f(x) = x + 1
'''
example FuncDecl, Statement '''
g(x) = {
    let x = 1
    x + 1
}
'''

example FuncDecl, Statement '''
h(x) =
    let x = 1
    x + 1
'''

FuncDecl = {
	name: Identifier
	"(" params: Params ")"
    (":" type: Type)?
    '=' _
    body: (IndentBlock / FuncMatch / Expression)
	#FuncDecl
}

Params = {
	(Param ( "," Param )* )?
}

Param = {
	name: Identifier
    (":" type: Type)?
    #Param
}

example FuncDecl, Statement '''
gcd(x,y) =
    | x                 if y == 0
    | gcd(y, x % y)
'''

FuncMatch = {
    FuncCase   FuncCase+
    #FuncMatch
}

example FuncCase '''
  | x                 if y == 0
'''

FuncCase = {
    __ '|' _ expr: Expression ('if' _ case: Expression / 'otherwise' _)?
    #FuncCase
}

IndentBlock = {
    @scope(
        @symbol(INDENT) Statement
        (@match(INDENT) Statement)+
    )
    #Block
}

ReturnStmt = {
	'return' __ expr: Expression
	#Return
}

/* Expression */

example FuncExpr, Expression \x x+1
example FuncExpr, Expression \x \y x+y

example IfExpr, Expression if(a > b) a + b else a - b
example IfExpr, Expression if(a < b) then a * b else a / b
example Expression true && false || !true
example Expression a == (b%2)^(c|1)
example Expression f(1,2)
example Expression d.name
example Expression d.f(1,2)

Expression =
    / BlockExpr
	/ FuncExpr
	/ IfExpr
	/ Operator

/* Expression */

BlockExpr = {
	"{"
	(Statement __)*
	"}"
	#Scope
}

IfExpr = {
    'if' _ cond: Expression
    ('then' __)? then: Expression
    ('else' __ else: Expression)?
	#IfExpr
}

/* FuncExpr */

FuncExpr = {
  '\\'
  params: LParams
  ('->' _)?
  right: Expression
  #FuncExpr
}

LParams = {
  (Param ('\\' Param)* / '()')
}

/* Operator */

Operator =
	AndExpr (left:^ { name: { OR #NameExpr } _ right: AndExpr #Infix })*

OR = '||' !'|'

AndExpr =
	EqExpr (left:^ { name: { AND #NameExpr } _ right: EqExpr #Infix })*

AND = '&&' !'&'

EqExpr =
	SumExpr (left:^ { name: { EQ #NameExpr } _ right: SumExpr #Infix })*

EQ =
	/ '==' !'='
	/ '!=' !'='
	/ '<=' !'='
	/ '>=' !'='
	/ '<'  !'<'
	/ '>'  !'>'

SumExpr =
	ProdExpr (left:^ { name: { SUM #NameExpr } _ right: ProdExpr #Infix })*

SUM =
	/ '++'
	/ '+'
	/ '-' !'>'
	/ '|' !'|'

ProdExpr =
	UnaryExpr (left:^ { name: { PROD #NameExpr } _ right: UnaryExpr #Infix })*

PROD =
	/ '/'
	/ '*'
	/ '%'
	/ '^'
	/ '<<'
	/ '>>'
	/ '&' !'&'

UnaryExpr
	= { name: {PRE #NameExpr} _ expr: UnaryExpr #Unary }
    / SuffixExpr

PRE =
    / '-' !'-'
    / '!'
    / '~'
    / '+'

SuffixExpr =
	Primary (
	    recv:^ { '.' _ name: Identifier "(" params: Expressions ")" #MethodExpr }
	    / recv:^ { '.' _ name: Identifier #GetExpr }
	    / recv:^ { "(" params: Expressions ")" #ApplyExpr }
	    / recv:^ { "[" params: Expressions "]" #IndexExpr }
	    / recv:^ { "<" type: Type ">" #CastExpr }
	)*

LeftHand =
    Identifier (
	    recv:^ { '.' _ name: Identifier #GetExpr }
    	/ recv:^ { "[" params: Expressions "]" #IndexExpr }
    )*


Expressions = {
	Expression? ( "," Expression )*
}

/* Primary */

example Primary, Expression (1,2) //
example Primary, Expression (1)
example Primary, Expression () //
example Primary, Expression [1,2,3]
example Primary, Expression { name: 'naruto', age: 17 }
example Primary, Expression {"name": 'naruto', "age": '17'}

Primary =
  / Defined
  /	GroupExpr
  / ListExpr
  / DataExpr
  / Constant
  / Identifier

/* Defined */

Defined = {
    'defined' _ "("
    { (![) ] .)+ #Symbol }
    _ ")"
    #Defined
}

GroupExpr = { "(" (Expression ("," Expression)* )?  ")" #TupleExpr }

ListExpr = { "[" (Expression ("," Expression)* )? ","?  "]" #ListExpr }

DataExpr = { "{" (KeyValue ("," KeyValue)*) / (':' _) ","? "}" #DataExpr }

KeyValue = {
	name: (Identifier/StringExpr)
	':' _
	value: Expression
}

/* Literal */

Constant =
    / TripleExpr
	/ StringExpr
	/ CharExpr
	/ FloatExpr
	/ IntExpr
	/ TrueExpr
	/ FalseExpr
	/ NullExpr

example StringExpr, Expression "\n\u1234a\0"
example CharExpr, Expression '\''
example IntExpr, Expression 0177
example IntExpr, Expression 0b1010_1010
example IntExpr, Expression 0xdeadbeaf
example IntExpr, Expression 0L
example FloatExpr, Expression 1.1e-9
example TrueExpr, Expression true

TripleExpr =
	'\'\'\'' { TemplateContent* #TemplateExpr } '\'\'\''

TemplateContent =
	'${' Expression '}'
	/ { (!'\'\'\'' !'${' .)* #StringExpr }

StringExpr = '"' { STRING_CONTENT* #StringExpr } '"' _
CharExpr = '\'' { CHAR_CONTENT* #CharExpr } '\'' _
STRING_CONTENT = ESCAPE / ![\"\n\\] .
CHAR_CONTENT   = ESCAPE / !['\n\\] .
ESCAPE =
	'\\' ['\"\\bfnrt]
	/ '\\' [0-3] [0-7] [0-7]
    / '\\' [0-7] [0-7]
    / '\\' [0-7]
	/ '\\' 'u'+ HEX HEX HEX HEX

IntExpr = {
	(DECIMAL / HEXADECIMAL / BINARY / OCTAL)
	#IntExpr
} _

DECIMAL = '0' ![bBxX0-9_] / [1-9] ( '_'* DIGIT )*
HEXADECIMAL = '0' [xX] HEX ( '_'* HEX )*
BINARY = '0' [bB] [01] ( '_'* [01] )*
OCTAL = '0' ( '_'* [0-7] )*
DIGIT = [0-9]
HEX = [a-fA-F0-9]
LONG_SUFFIX = [lL]

FloatExpr = {
	FLOAT #DoubleExpr
} _

Var1  = { [A-Za-z] [0-9]? [']* #NameExpr }  // xy => x * y
      / '(' _ Expression ')'                // 2(n+1) => 2 * (n+1)

FLOAT =
	FRACTION EXPONENT?
    / DIGIT+ EXPONENT

FRACTION =
	!'_' ( '_'* DIGIT )* '.' DIGIT ( '_'* DIGIT )*
    / DIGIT ( '_'* DIGIT )* '.' !'.'

EXPONENT =
	[eE] [+\-]? DIGIT ( '_'* DIGIT )*

TrueExpr  = { [Tt] 'rue' !W  #TrueExpr } _
FalseExpr = { [Ff] 'alse' !W #FalseExpr } _
NullExpr  = { [Nn] ('ull' / 'one' / 'il' / 'othing' ) / 'NULL' #NullExpr } _

/* CodeMap */

OrigamiFile = __ { (Origami __)* #Block } EOF

Origami =
    / CodeInclude
    / CodeRequire
    / CodeMap

CodeInclude = {
    'include' SPC file: Code
    #Include
}

CodeRequire = {
    'require' SPC file: Code
    #Require
}

CodeMap = {
    name: Signature
    (":" type: Type)?
    ('=' _ expr: (StringExpr / Code))?
    (delim: StringExpr)?
    #CodeMap
}

Signature = {
    '#'?
    (OPNAME / NAME )
    ('@' DIGIT+ )?
    #Symbol
} _

Code = {
    ( !NL . )*
    #Symbol
} NL _

example CodeMap +@2 : (Int,Int)->Int = (%1+%2)
example CodeMap +@2 : (Int,Int)->Int
example CodeMap +@2 = (%1+%2)
example CodeMap + = (%1+%2)
example CodeMap + = "(%*)" ","

example OrigamiFile '''
+@2 : (Int,Int)->Int = (%1+%2)
+@2 : (Int,Int)->Int
+@2 = (%1+%2)
'''
